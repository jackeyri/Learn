---
title: 网络协议及应用开发期末复习
author: Jackeyri
---

# 题型

## A卷

### 一、选择题

（共12题，24分）

1. 关于Linux系统描述错误的是：*Linux产品都可以无偿使用*。

2. 在网络编程中NAT是：*物理地址转换*。

3. 如果你想在gdb中查看程序的寄存器的状态，应该使用*`info registers`*命令。

4. 地址解析协议（ARP）是向网络查询目录主机的IP地址，并获得其对应的物理地址的一种协议。

   Ping命令是基于ICMP协议的一种应用。

   DNS协议实现域名到IP的转换。

   telnet协议在传输用户名和密码时是明文传输。

   ARP是根据IP地址获得MAC地址转换协议，DNS协议用于域名解析。

5. 路由器工作时对应的网络层次是：*网络层*。

6. 建立TCP连接需要三次握手，从编程的角度来看，*`connect`*可以发起TCP连接。

7. *`gethostbyname`*函数可以实现域名转换为IP地址的功能。

8. Java网络通信使用的类

   | 类名           | 协议 | 说明                                        |
   | -------------- | ---- | ------------------------------------------- |
   | Socket         | tcp  | 实现 tcp 的客户端连接，数据传输功能的类     |
   | ServerSocket   | tcp  | 实现 tcp 服务端，执行端口绑定和监听功能的类 |
   | DatagramSocket | udp  | UDP 通信 socket 对象                        |
   | DatagramPacket | udp  | UDP 数据包                                  |

9. NIO中主要包括四个Channel

   | NIO 通道名称        | 操作对象           | BIO 对应类     |
   | ------------------- | ------------------ | -------------- |
   | FileChannel         | 文件               | File           |
   | DatagramChannel     | udp                | DatagramSocket |
   | SocketChannel       | tcp 客户端数据通信 | Socket         |
   | ServerSocketChannel | tcp 服务端         | ServerSocket   |

10. 不同编程语言生成的通信程序在通信须采用相同的字符编码方案，否则会发生字符显示时乱码或无法显示的现象。在所有编码方案中，较佳的字符编码方案是*`UTF-8`*。

11. 

### 二、填空题

（共11题，22分）

1. 在Linux下查看主机IP地址使用的命令是：*`ifconfig`*。

2. 在Linux平台的*`ps -ef`*命令可以查看当前运行的所有进程。

3. 配置网卡ens32的IP地址为192.168.0.1和子网掩码为255.255.255.0的命令是*`ifconfig ens32 192.168.0.1 netmask 255.255.255.0`*。

4. 在Windows宿主机系统上安装Ubuntu，此时Windows需要身份认证方式接入互联网，为了使虚拟机中的Ubuntu系统也能接入互联网，则虚拟机的网卡应该采用*`NAT`*模式。

5. 在Makefile中，$@是特殊的自动变量，代表当前规则的*目标文件*。

6. 基于TCP/IP的参考模型分为四个层次，它们分别是*网络接口层*、*网络互联层*、*传输层*、*应用层*。

7. 处于连接状态的TCP断开连接的方法是*`shutdown`*，对方通过*recv返回值为0*得知断开。

8. QT中信号是对象在QT内状态的改变事件，对于内置对象，信号是事先定义好的，例如readUdpSock事件指UDP数据到达。而槽函数是用户编写的处理函数，信号与槽的连接是通过QObject的*`connect`*成员函数来实现的。

9. 该程序结果有*`16`*行文本输出。

   ~~~c
   #include <stdio.h>
   #include <unistd.h>
   int main(int argc, char* argv[]) {
       pid_t pid;
       pid = fork();
       pid = fork();
       pid = fork();
       pid = fork();
       printf("当前进程 ID 号为: [%d]\n", getpid());
       return 0;
   }
   ~~~

10. Linux平台创建线程使用的函数是*`pthread_create`*。

11. 

### 三、简答题

（共5题，20分）

1. 简述TCP和UDP协议的区别。

   - TCP与UDP都是传输层的协议。
   - TCP面向字节流，UDP面向数据报。
   - TCP是可靠的传输，UDP会丢包，是不可靠的传输。 
   - TCP常用于文件传输，UDP常用于语音、视频等数据的传输。

2. 简述TCP三次握手。

   - 第一次握手：客户端向服务器发送一个SYN报文，请求建立连接。
   - 第二次握手：服务器收到SYN报文后，向客户端发送一个SYN/ACK报文，确认收到客户端的请求，并请求建立连接。
   - 第三次握手：客户端收到SYN/ACK报文后，向服务器发送一个ACK报文，确认收到服务器的请求，并建立连接。

3. Linux系统中有一个名为066-brev的文件夹，含有三个QT程序源文件，分别是main.cpp、receive.cpp和reveive.h，请根据下表的意义写出相应的命令。

   | 命令           | 意义                           |
   | -------------- | ------------------------------ |
   | qmake -project | 生成工程文件                   |
   | qmake          | 根据工程文件生成Makefile       |
   | make           | 根据Makefile编译生成可执行文件 |
   | ./066-brev     | 运行可执行文件                 |

4. 数据包是由IP地址为*`10.1.8.244`*（Source）的主机发送给IP地址为*`183.2.172.42`*（Destination）的主机，使用的是*`ICMP`*（Protocol）协议，有*`98`*（Length）字节。

   ![Wireshark](.\网络协议及应用开发期末复习.access\Wireshark.png)

5. 根据IP报文头信息结构补全IP首部的结构体定义。

   ![IP报文头信息结构](.\网络协议及应用开发期末复习.access\IP报文头信息结构.png)

   ~~~c
   typedef struct _iphdr {
       unsigned char h_verlen;         // 首部长度 + IP 版本号
       unsigned char h_verlen;         // 服务类型
       unsigned short total_len;       // TODO: 总长度
       unsigned short ident;           // TODO: 标识
       unsigned short frag_and_flags;  // 标志位 + 片偏移
       unsigned char ttl;              // TODO: 生存时间
       unsigned char proto;            // 协议代码
       unsigned short checksum;        // TODO: 校验和
       unsigned int sourceIP;          // 源 IP 地址
       unsigned int destIP;            // 目标 IP 地址
   } IP_HEADER;
   ~~~

### 四、综合问答题

（共3题，18分）

1. 补全文件传输发送端程序代码。

   ~~~c
   #include <errno.h>
   #include <netdb.h>
   #include <netinet/in.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <sys/file.h>
   #include <sys/socket.h>
   #include <sys/stat.h>
   #include <sys/types.h>
   #include <unistd.h>
   #define FILE_NAME_LEN 128
   #define SERVPORT 1300
   #define MAX_CONNECTED_NO 10
   #define MAXDATASIZE 50
   int main(int argc, char* argv[]) {
       int sockfd, sendbytes;
       char buf[MAXDATASIZE];
       char file_name[FILE_NAME_LEN];
       struct hostent* host;
       struct sockaddr_in serv_addr;
       int fd = 0;
       int totalbytes = 0;
       int readbytes = 0;
       if (argc < 2) {
           fprintf(stderr, "Please enter the server's hostname!\n");
           exit(1);
       }
       if ((host = gethostbyname(argv[1])) == NULL) {
           perror("gethostbyname");
           exit(1);
       }
       if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
           perror("socket");
           exit(1);
       }
       serv_addr.sin_family = AF_INET;
       serv_addr.sin_port = htons(SERVPORT);
       serv_addr.sin_addr = *((struct in_addr*)host->h_addr_list[0]);
       bzero(&(serv_addr.sin_zero), 8);
       if (connect(sockfd, (struct sockaddr*)&serv_addr,
                   sizeof(struct sockaddr)) == -1) {
           perror("connect");
           exit(1);
       }
       printf("please input the file you want to open:\n");
       // 清空文件名字符串缓冲区
       memset(file_name, 0, strlen(file_name));
       scanf("%s", file_name);  // TODO: 输入文件名字符
       printf("filename is %s\n", file_name);
       fd = open(file_name, O_RDONLY, 0666);
       if (fd < 0) {
           perror("open file error.");
           exit(1);
       }
       send(sockfd, file_name, strlen(file_name), 0);  // TODO: 将文件名字符串发送给接收端
       printf("press s to send file\n");
       getchar();
       while ((readbytes = read(fd, buf, MAXDATASIZE))) {
           if ((sendbytes = send(sockfd, buf, readbytes, 0)) == -1) {
               perror("send");
               exit(1);
           }
           totalbytes += sendbytes;  // TODO: 累加当前已发送的字节数
       }
       printf("sent %d bytes.\n", totalbytes);
       close(sockfd);  // TODO: 关闭套接字资源
   }
   ~~~

2. 根据IntToByte写出ByteToInt。

   ~~~c
   void IntToByte(int iData, char* cData) {
       union IntChar {
           int a;      // 4 bytes
           char b[4];  // 4 byte
       } InCh;
       InCh.a = iData;
       cData[0] = InCh.b[0];
       cData[1] = InCh.b[1];
       cData[2] = InCh.b[2];
       cData[3] = InCh.b[3];
   }
   ~~~

   ~~~c
   int ByteToInt(char* cData) {
       union IntChar {
           int a;      // 4 bytes
           char b[4];  // 4 byte
       } InCh;
       InCh.b[0] = cData[0];
       InCh.b[1] = cData[1];
       InCh.b[2] = cData[2];
       InCh.b[3] = cData[3];
       return InCh.a;
   }
   ~~~

3. 补全阻塞式UDP通信程序代码。

   ~~~java
   import java.io.*;
   import java.net.DatagramPacket;
   import java.net.DatagramSocket;
   
   public class UdpRv {
       public static void main(String[] args) throws IOException {
           DatagramSocket serviceSocket = new DatagramSocket(8888); // TODO: 使用 DatagramSocket 指定端口，创建接收端
           byte[] container = new byte[1024];
           DatagramPacket dataPacket = new DatagramPacket(container, 1024);
           serviceSocket.receive(dataPacket); // TODO: 阻塞式接收包裹 receive(DatagramPacket p)
           byte[] data = dataPacket.getData();
           int len = dataPacket.getLength();
           System.out.println(new String(data, 0, len)); // TODO: 分析数据
           serviceSocket.close(); // TODO: 释放资源
       }
   }
   ~~~

### 五、编程题

（共2题，16分）

1. 补全TCP服务端程序代码。

   ~~~c
   #include <arpa/inet.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <sys/socket.h>
   #include <unistd.h>
   void error_handling(char* message);
   int main(int argc, char* argv[]) {
       int serv_listen_sock;  // 服务端负责监听的 socket 文件标识
       int serv_data_sock;    // 服务端负责数据通信的 socket 文件标识
       struct sockaddr_in serv_addr;
       struct sockaddr_in clnt_addr;
       socklen_t clnt_addr_size;
       char message[] = "Hello embedded.";
       if (argc != 2) {
           printf("Usage: %s <port>.", argv[0]);
           exit(1);
       }
       serv_listen_sock =
           socket(PF_INET, SOCK_STREAM, 0);  // TODO: 创建一个 TCP 的 socket 资源
       if (serv_listen_sock == -1) {
           error_handling("serv_listen_sock create() error.");
       }
       memset(&serv_addr, 0, sizeof(serv_addr));
       serv_addr.sin_family = AF_INET;
       serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
       serv_addr.sin_port = htons(atoi(argv[1]));
       if (bind(serv_listen_sock, (struct sockaddr*)&serv_addr,
                sizeof(serv_addr)) == -1) {  // TODO: 端口绑定
           error_handling("bind() error.");
       }
       if (listen(serv_listen_sock, 5) == -1) {  // TODO: 执行监听
           error_handling("bind() error.");
       }
       clnt_addr_size = sizeof(clnt_addr);
       serv_data_sock = 
           accept(serv_listen_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);  // TODO: 实现连接请求响应
       if (serv_data_sock == -1) {
           error_handling("bind() error");
       }
       write(serv_data_sock, message, sizeof(message));
       shutdown(serv_data_sock, SHUT_RDWR);
       close(serv_data_sock);
       close(serv_listen_sock);
       return 0;
   }
   // 错误处理是将信息输出到标准输出，然后退出进程
   void error_handling(char* message) {
       fputs(message, stderr);
       fputc('\n', stderr);
       exit(1);
   }
   ~~~

2. 补全Makefile文件代码。

   当前目录下有一个工程共有五个源文件：mytool1.c、mytool1.h、mytool2.c、mytool2.h和main.c

   main.c引用头文件mytool1.h和mytool2.h

   mytool1.c引用头文件mytool1.h

   mytool2.c引用头文件mytool2.h

   - 常规写法：

     ~~~makefile
     main:main.o mytool1.o mytool2.o
     	gcc -o main main.o mytool1.o mytool2.o
     main.o:main.c mytool1.o mytool2.o
     	gcc -c main.c
     mytool1.o:mytool1.c mytool1.h
     	gcc -c mytool1.c
     mytool2.o:mytool2.c mytool2.h
     	gcc -c mytool2.c
     clean:
     	rm -f *.o main
     ~~~

   - 使用变量：

     ~~~makefile
     OFILES = main.o mytool1.o mytool2.o
     main:$(OFILES)
     	gcc -o main $(OFILES)
     main.o:main.c mytool1.h mytool2.h
     	gcc -c main.c
     mytool1.o:mytool1.c mytool1.h
     	gcc -c mytool1.c
     mytool2.o:mytool2.c mytool2.h
     	gcc -c mytool2.c
     clean:
     	rm -f main $(OFILES)
     ~~~

   - 使用自动推导：

     ~~~makefile
     CC = gcc
     OFILES = main.o mytool1.o mytool2.o
     main:$(OFILES)
     	$(CC) -o main $(OFILES)
     main.o:mytool1.h mytool2.o
     mytool1.o:mytool1.h
     mytool2.o:mytool2.h
     clean:
     	rm -f main $(OFILES)
     ~~~

## B卷

### 一、选择题

（共12题，24分）

1. IP头部校验和用于确保*IP头部*数据的完整性。

### 二、填空题

（共11题，22分）

1. OSI七层参考模型：应用层、表示层、*会话层*、*传输层*、*网络层*、*数据链路层*、物理层。

2. TCP通讯中调用*`shutdown`*方法实现稳妥断开。

3. 创建进程可使用的方法有fork、system、exec函数调用。在Linux系统中，创建新进程最常用的系统调用是*`fork()`*。

4. Linux平台等待另一线程结束使用的函数是*`pthread_join`*。

5. Linux平台线程分离函数是*`pthread_detach`*。

6. Linux平台使用GCC编译一个名为thread.c的多线程程序的命令是*`gcc thread.c -o output -lpthread`*。

### 三、简答题

（共5题，20分）

1. Linux平台TCP实现多连接的五种典型方式。

   - 多进程方式
   - 多线程方式
   - select方式
   - poll方式
   - epoll方式

   Linux平台支持并发TCP连接的服务器模式有多进程，多线程，基本select的I/O复用，epoll模式，其中epoll模式是性能最好的。

2. 简述TCP协议的主要特点。

   - 面向连接：在数据传输前需要建立连接。
   - 可靠传输：通过序列号、确认应答机制保证数据的顺序和完整性。
   - 流量控制：通过滑动窗口机制控制发送速率，适应接收方的处理能力。
   - 拥塞控制：通过拥塞窗口调整发送速率，防止网络过载。

3. TCP服务端支持多连接有五种典型模式。

   - select的IO复用
   - poll模式
   - epoll模式
   - 多进程模式
   - 多线程模式

### 四、综合问答题

（共3题，18分）

1. 分析程序输出打印结果。

   ~~~c
   #include <stdio.h>
   #include <stdlib.h>
   int main() {
       char *p1 = malloc(100);
       char p2[100];
       printf("sizeof p1 = %d, sizeof p2 = %d\n", sizeof(p1), sizeof(p2));
       free(p1);
       return 0;
   }
   ~~~

   这个程序的结果会打印`sizeof p1 = 8, sizeof p2 = 100`

   **`sizeof p1`**:

   - `p1`是一个指向`char`的指针，即`char *`。
   - `sizeof(p1)`返回的是指针类型的大小，而不是指向的内存块的大小。在大多数64位系统上，指针的大小是8个字节，所以`sizeof(p1)`返回8。
   - 在32位系统上，指针的大小是4个字节，所以`sizeof(p1)`会返回4。

   **`sizeof p2`**:

   - `p2`是一个长度为100的字符数组，即`char p2[100]`。
   - `sizeof(p2)`返回的是数组的大小，即100个字符的大小。所以`sizeof(p2)`返回100。

2. 分析程序的错误的地方。

   ~~~c
   #include <stdio.h>
   int *p = NULL;
   int x;
   int *fFun(void) {
       int i = 0;
       printf("variant i's address is 0x%x and value is %d\n", &i, i);
       return &i;
   }
   void subFun(void) {
       (*p)--;
       printf("pointer p's address is 0x%x and value is %d\n", p, *p);
   }
   void gFun(void) {
       int j;
       printf("variant j's address is 0x%x and value is %d\n", &j, j);
       for (j = 0; j < 10; j++) {
           subFun();
           printf("%d\n", j);
       }
       int main(void) {
           p = fFun();
           gFun();
       }
   }
   ~~~

   **返回局部变量的地址**：

   - 在 `fFun` 函数中，`int i` 是一个局部变量，在函数返回后它的作用域结束，它的地址不再有效。
   - 返回局部变量的地址会导致未定义行为，因为该内存位置可能会被其他代码覆盖。
   - `return &i;` 返回了一个无效的地址。

3. 分析程序错误的地方。

   ~~~c
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   void GetMemory(char *p) {
       p = (char *)malloc(100);
   }
   void CalcBlank(void) {
       char *str = NULL;
       char *ptr = NULL;
       unsigned int i = 0;
       GetMemory((char *)str);
       strcpy(str, "Karl marx is born in Germany and German is his native language\n");
       ptr = str;
       while ('\0' != (*ptr)) {
           if (*ptr == ' ') {
               i++;
           }
           ptr++;
       }
       printf("the blank number is %d", i);
       free(ptr);
   }
   int main(void) {
       CalcBlank();
       return 0;
   }
   ~~~

   修改：

   - 把`GetMemory(char *p);`改为`GetMemory(char **p);`
   - 把`p = (char *)malloc(100);`改为`*p = (char *)malloc(100);`
   - 把`GetMemory((char *)str);`改为`GetMemory((char **)&str);`
   - 把`free(ptr);`改为`free(str);`

### 五、编程题

（共2题，16分）

1. 补全TCP客户端程序代码。

   ~~~c
   #include <arpa/inet.h>
   #include <stdio.h>
   #include <stdlib.h>
   #include <string.h>
   #include <sys/socket.h>
   #include <unistd.h>
   void error_handling(char* message);
   int main(int argc, char* argv[]) {
       int sock;
       struct sockaddr_in serv_addr;
       char message[30];
       int str_len;
       if (argc != 3) {
           printf("Usage: %s <IP> <PORT>.", argv[0]);
           exit(1);
       }
       sock =
           socket(PF_INET, SOCK_STREAM, 0);  // TODO: 创建一个 TCP 的 socket 资源
       if (sock == -1) {
           error_handling("socket() create failed.");
       }
       memset(&serv_addr, 0, sizeof(serv_addr));
       serv_addr.sin_family = AF_INET;
       serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
       serv_addr.sin_port = htons(atoi(argv[2]));
       if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {  // TODO: 连接服务器
           error_handling("connect() failed.");
       }
       str_len =
           read(sock, message, sizeof(message) - 1);  // TODO: 从服务器接收消息
       if (str_len == -1) {
           error_handling("read() failed.");
       }
       printf("Message from server: %s\n", message);
       shutdown(sock, SHUT_RDWR);  // TODO: 使用 shutdown() 函数关闭套接字的双向通信关闭套接字
       close(sock);
       return 0;
   }
   // 错误处理是将信息输出到标准输出，然后退出进程
   void error_handling(char* message) {
       fputs(message, stderr);
       fputc('\n', stderr);
       exit(1);
   }
   ~~~

2. 补全Makefile文件代码。

   当前目录下有一个工程共有五个源文件：mytool1.c、mytool1.h、mytool2.c、mytool2.h和main.c

   main.c引用头文件mytool1.h和mytool2.h

   mytool1.c引用头文件mytool1.h

   mytool2.c引用头文件mytool2.h

   - 常规写法：

     ~~~makefile
     main:main.o mytool1.o mytool2.o
     	gcc -o main main.o mytool1.o mytool2.o
     main.o:main.c mytool1.o mytool2.o
     	gcc -c main.c
     mytool1.o:mytool1.c mytool1.h
     	gcc -c mytool1.c
     mytool2.o:mytool2.c mytool2.h
     	gcc -c mytool2.c
     clean:
     	rm -f *.o main
     ~~~

   - 使用变量：

     ~~~makefile
     OFILES = main.o mytool1.o mytool2.o
     main:$(OFILES)
     	gcc -o main $(OFILES)
     main.o:main.c mytool1.h mytool2.h
     	gcc -c main.c
     mytool1.o:mytool1.c mytool1.h
     	gcc -c mytool1.c
     mytool2.o:mytool2.c mytool2.h
     	gcc -c mytool2.c
     clean:
     	rm -f main $(OFILES)
     ~~~

   - 使用自动推导：

     ~~~makefile
     CC = gcc
     OFILES = main.o mytool1.o mytool2.o
     main:$(OFILES)
     	$(CC) -o main $(OFILES)
     main.o:mytool1.h mytool2.o
     mytool1.o:mytool1.h
     mytool2.o:mytool2.h
     clean:
     	rm -f main $(OFILES)
     ~~~

# 知识点

1. Linux创始人：Linux Torvalds

2. Linux文件权限描述符：d表示目录（directory），r表示读（read），w表示写（write），x表示执行（execute）

3. Linux常用命令

   | 命令     | 作用                                                         |
   | -------- | ------------------------------------------------------------ |
   | pwd      | 查看目前所在的工作目录                                       |
   | su       | 更改登录用户，默认为root（超级用户）                         |
   | cp       | 将一个文件拷贝到另一个位置，原文件不变                       |
   | chmod    | 修改文件或目录的权限<br>例如`chmod u=rwx, g=rx, o=x file`等同于`chmod 751 file`<br>给属主分配读、 写、执行的权限（7）<br>给所在组分配读、执行的权限（5）<br>给其他用户分配执行的权限（1） |
   | uname    | 查看内核名称                                                 |
   | uname -r | 查看内核版本号                                               |
   | uname -a | 查看内核版本号、硬件架构、主机名称和系统类型等               |
   | rm       | 删除目录或文件                                               |
   | rm -rf   | 强制删除文件或目录，包括子目录                               |

4. GCC工具

   在Linux平台编译成功的C源码不能在Windows平台编译运行。Linux平台对包含大量源码的项目进行有效的编译管理工具是make工具。经过gcc编译成功的程序在只适用特定的硬件平台的linux系统，不同硬件平台一般不能运行。gcc工具在编译某些源码时有时还需要指定专门的库才能编译成功。

   编译命令：`gcc source.c -o output`

   | 参数     | 作用                                  |
   | -------- | ------------------------------------- |
   | o        | 指定输出文件的名称                    |
   | g        | 为gdb调试工具产生符号信息，调试程序用 |
   | lpthread | 支持线程代码                          |

5. main函数输入参数

   ~~~c
   int main(int argc, char** argv)
   ~~~

   **`int argc`**:

   - `argc` 是一个整数，表示命令行参数的个数。它包括程序名本身，因此至少为 1。
   - 例如，如果在命令行输入 `./program arg1 arg2`，那么 `argc` 的值是 3。

   **`char** argv`**:

   - `argv` 是一个指向字符指针数组的指针，即一个字符串数组。每个元素指向一个命令行参数。
   - `argv[0]` 通常是程序名，`argv[1]` 是第一个命令行参数，`argv[2]` 是第二个命令行参数，以此类推。
   - 例如，对于命令 `./program arg1 arg2`，`argv` 将是一个数组，其中 `argv[0]` 是 `"./program"`，`argv[1]` 是 `"arg1"`，`argv[2]` 是 `"arg2"`。

6. GDB是UNIX和Linux平台下字符界面的调试工具，可以用它在linux上调试C和C++程序。

   使用GCC工具编译时需加上`-g`参数：`gcc source.c -o output –g`。

   两种运行方式：

   - 编译后输入`gdb output`。
   - 在命令行中先输入gdb进入gdb调试模式，再输入`file output`。

7. OSI七层模型和TCP/IP四层模型对应关系：

   ~~~mermaid
   graph LR
       subgraph OSI模型
           A1[应用层]
           A2[表示层]
           A3[会话层]
           A4[传输层]
           A5[网络层]
           A6[数据链路层]
           A7[物理层]
       end
   
       subgraph TCP/IP模型
           B1[应用层]
           B2[传输层]
           B3[互联网层]
           B4[网络接口层]
       end
   
       A1 --> B1
       A2 --> B1
       A3 --> B1
       A4 --> B2
       A5 --> B3
       A6 --> B4
       A7 --> B4
   ~~~

8. Socket函数

   | 函数名 | 说明                                                         |
   | ------ | ------------------------------------------------------------ |
   | socket | 创建一个socket文件资源（TCP、UDP和RawSock），用于通讯（UDP和TCP意义不一样）。 |
   | bind   | 绑定本地IP地址和端口。（UDP和TCP使用意义不一样）             |
   | listen | 开始执行监听。（TCP）                                        |
   | accept | 服务端收到客户端连接请求后，创建一个新的用于数据通讯的socket文件资源，不同于监听的socket资源，无连接请求则该方法阻塞。（TCP） |
   | send   | 向目标主机发送字节序列。（TCP）                              |
   | recv   | 接收网络发来的字节序列（TCP），函数返回值是实际收到的字节个数，如果对方使用了 shutdown 方法，则该方法返回值为0，对方无动作，则该方法阻塞。 |
   
9. UDP通讯中使用的方法是：socket、bind、sendto、receivefrom、close。UDP是常用的无连接的网络协议，SNMP网络管理的协议就是基于UDP的应用层协议。

10. TCP通讯中调用shutdown方法实现稳妥断开。TCP是网络中最常用的面向连接的网络层协议，HTTP、FTP等协议就是基于TCP协议的应用层协议。

11. Java命令

    - `javac HelloWorld.java`编辑java
    - `java HelloWorld`运行字节码文件

12. JAVA中基础的DatagramSocket，Socket，ServerSocket所使用的方法都是属于BIO。